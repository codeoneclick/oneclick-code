struct vertex
{
    float3 position    : POSITION;
    float2 texcoord    : TEXCOORD0;
};

struct fragment
{
	float4 position    : POSITION;
	float2 texcoord_01 : TEXCOORD0;
	float3 colorYxy    : TEXCOORD1;
};

#define	EPS	0.1

uniform float4x4  mWorldViewProjection;
uniform float4x4  mWorldViewInverse;

uniform float4    vCameraEye;
uniform float4    vLightDirection;


float3 perezZenith ( float t, float thetaSun )
{
	const float	pi = 3.1415926;
	const float4	cx1 = float4 ( 0,       0.00209, -0.00375, 0.00165  );
	const float4	cx2 = float4 ( 0.00394, -0.03202, 0.06377, -0.02903 );
	const float4	cx3 = float4 ( 0.25886, 0.06052, -0.21196, 0.11693  );
	const float4	cy1 = float4 ( 0.0,     0.00317, -0.00610, 0.00275  );
	const float4	cy2 = float4 ( 0.00516, -0.04153, 0.08970, -0.04214 );
	const float4	cy3 = float4 ( 0.26688, 0.06670, -0.26756, 0.15346  );

	float	t2    = t*t;							// turbidity squared
	float	chi   = (4.0 / 9.0 - t / 120.0 ) * (pi - 2.0 * thetaSun );
	float4	theta = float4 ( 1, thetaSun, thetaSun*thetaSun, thetaSun*thetaSun*thetaSun );

	float	Y = (4.0453 * t - 4.9710) * tan ( chi ) - 0.2155 * t + 2.4192;
	float	x = t2 * dot ( cx1, theta ) + t * dot ( cx2, theta ) + dot ( cx3, theta );
	float	y = t2 * dot ( cy1, theta ) + t * dot ( cy2, theta ) + dot ( cy3, theta );

	return float3( Y, x, y );
}

float3	perezFunc ( float t, float cosTheta, float cosGamma )
{
	float	gamma      = acos ( cosGamma );
	float	cosGammaSq = cosGamma * cosGamma;
	float	aY =  0.17872 * t - 1.46303;
	float	bY = -0.35540 * t + 0.42749;
	float	cY = -0.02266 * t + 5.32505;
	float	dY =  0.12064 * t - 2.57705;
	float	eY = -0.06696 * t + 0.37027;
	float	ax = -0.01925 * t - 0.25922;
	float	bx = -0.06651 * t + 0.00081;
	float	cx = -0.00041 * t + 0.21247;
	float	dx = -0.06409 * t - 0.89887;
	float	ex = -0.00325 * t + 0.04517;
	float	ay = -0.01669 * t - 0.26078;
	float	by = -0.09495 * t + 0.00921;
	float	cy = -0.00792 * t + 0.21023;
	float	dy = -0.04405 * t - 1.65369;
	float	ey = -0.01092 * t + 0.05291;

	return float3 ( (1.0 + aY * exp(bY/cosTheta)) * (1.0 + cY * exp(dY * gamma) + eY*cosGammaSq),
	              (1.0 + ax * exp(bx/cosTheta)) * (1.0 + cx * exp(dx * gamma) + ex*cosGammaSq),
				  (1.0 + ay * exp(by/cosTheta)) * (1.0 + cy * exp(dy * gamma) + ey*cosGammaSq) );
}

float3	perezSky ( float t, float cosTheta, float cosGamma, float cosThetaSun )
{
	float	thetaSun = acos        ( cosThetaSun );
	float3	zenith   = perezZenith ( t, thetaSun );
	float3	clrYxy   = zenith * perezFunc ( t, cosTheta, cosGamma ) / perezFunc ( t, 1.0, cosThetaSun );
	
	clrYxy [0] *= smoothstep ( 0.0, EPS, cosThetaSun );			// make sure when thetaSun > PI/2 we have black color
	
	return clrYxy;
}

fragment main( vertex IN )
{
	fragment OUT;
	
	float3 v   = normalize ( IN.position.xzy);
	float3 l   = normalize ( vLightDirection.xyz );
	float lv   = dot  ( l, v );
	float3 colorYxy = perezSky ( 10.0f, v.z + 0.05f, lv, l.z );
	OUT.colorYxy    = colorYxy;
	OUT.position    = mul( mWorldViewProjection, float4(IN.position,1.0f) );
	OUT.texcoord_01 = IN.texcoord;
	return OUT;
}
