struct vertex
{
    float3 vPosition    : ATTR0;
    float2 vTexCoord    : ATTR1;
    float4 vExtValue    : ATTR5;
};

struct fragment
{
	float4   vPosition       : POSITION;
	float4   vTexCoordProj   : TEXCOORD0;
	float2   vTexCoord       : TEXCOORD1;
	float3x3 mTangentSpace   : TEXCOORD2;
	float3   vCamera         : TEXCOORD5;
	float3   vLight	         : TEXCOORD6;
	float    fExtValue       : TEXCOORD7;
};

uniform float4x4  mWorldViewProjection;
uniform float4x4  mWorldViewInverse;
uniform float4x4  mWorldView;
uniform float4x4  mWorld;
uniform float4x4  mReflection;

uniform float4    vCameraEye;
uniform float4    vLightDirection;

uniform float fTimer;

struct sWave
{
	float	fFrequency;	 // Frequency (2PI / Wavelength)
	float	fAmplitude;	 // Amplitude
	float	fPhase;	     // Phase (Speed * 2PI / Wavelength)
	float2	vDirection;  // Direction
};

#define NUMWAVES 3
sWave Waves[NUMWAVES] = 
{
	{ 0.4f, 1.75f, 0.50f, float2( -1.0f, 0.0f ) },
	{ 0.5f, 1.5f, 1.30f, float2( -0.7f, 0.7f ) },
	{ 0.6f, 1.75f, 0.250f, float2( 0.2f, 0.1f ) },
};

fragment main(vertex IN)
{
	fragment OUT;
	
	float fWaterLevel = 24.0f;
	
	for( int i = 0; i < NUMWAVES; i++ )
		if(IN.vExtValue.x < fWaterLevel)
    		IN.vPosition.y += min(1.0f/IN.vExtValue.x, 0.25f) * Waves[i].fAmplitude * sin( dot( Waves[i].vDirection, IN.vPosition.xz ) * Waves[i].fFrequency + fTimer * 5.0f * Waves[i].fPhase );
    
    OUT.vTexCoord = IN.vTexCoord;
    //float fExtValue = length(float3(vCameraEye.x - IN.vPosition.x, vCameraEye.y - IN.vExtValue.x, vCameraEye.z - IN.vPosition.z));
    OUT.fExtValue = clamp(IN.vExtValue.x/(fWaterLevel * 2.0f),0.0f,1.0f);
    
    float3 vBinormal = float3( 1.0f,  0.0f, 0.0f );
    float3 vTangent  = float3( 0.0f,  0.0f, 1.0f );
    float3 vNormal   = float3( 0.0f,  1.0f, 0.0f );
    
	float3x3 mTangentSpace = float3x3(4.0f * vTangent, 4.0f * vBinormal, vNormal );
	
	OUT.mTangentSpace[0].xyz = mul( mTangentSpace, mWorld[0].xyz );
	OUT.mTangentSpace[1].xyz = mul( mTangentSpace, mWorld[1].xyz );
	OUT.mTangentSpace[2].xyz = mul( mTangentSpace, mWorld[2].xyz );
	
    OUT.vCamera  = mul(OUT.mTangentSpace, vCameraEye.xyz - IN.vPosition);
    OUT.vLight   = mul(OUT.mTangentSpace, vLightDirection.xyz);

	OUT.vPosition     = mul(mWorldViewProjection, float4(IN.vPosition,1.0f) );
	OUT.vTexCoordProj = OUT.vPosition;
	return OUT;
}
