struct fragment
{
	float4 vPosition        : POSITION;
	float4 vMultiTexBlend   : TEXCOORD4;
	float2 vTexCoord        : TEXCOORD0;
	float3 vLight           : TEXCOORD1;
	float3 vCamera          : TEXCOORD2;
	float2  fClipValue      : TEXCOORD3;
};

struct pixel
{
	float4 color : COLOR;
};

uniform sampler2D Texture_01;
uniform sampler2D Texture_02;
uniform sampler2D Texture_03;

uniform sampler2D Texture_04;
uniform sampler2D Texture_05;
uniform sampler2D Texture_06;

uniform float bReflectionPass;

pixel main(fragment IN)
{
	pixel OUT;
	
	float fTile = 2.0f;
	
    IN.vCamera = normalize(IN.vCamera);
    IN.vLight = normalize(IN.vLight);
    
    IN.vTexCoord *= 2.0f;
	
    float fHeightPower = tex2D(Texture_04, IN.vTexCoord).a * IN.vMultiTexBlend.x + 
						 tex2D(Texture_05, IN.vTexCoord).a * IN.vMultiTexBlend.y + 
						 tex2D(Texture_06, IN.vTexCoord).a * IN.vMultiTexBlend.z;
   
    fHeightPower *= 0.04f;
    float2 vDisplaceTexCoord = IN.vTexCoord + (-IN.vCamera.xy * fHeightPower);
    
    float3 vNormalColor = tex2D(Texture_04, vDisplaceTexCoord).rgb * IN.vMultiTexBlend.x + 
						  tex2D(Texture_05, vDisplaceTexCoord).rgb * IN.vMultiTexBlend.y + 
						  tex2D(Texture_06, vDisplaceTexCoord).rgb * IN.vMultiTexBlend.z;
	
	vNormalColor = vNormalColor * 2 - 1;
	
	float4 vDiffuceColor =  tex2D( Texture_01, vDisplaceTexCoord )*IN.vMultiTexBlend.x + 
							tex2D( Texture_02, vDisplaceTexCoord )*IN.vMultiTexBlend.y + 
							tex2D( Texture_03, vDisplaceTexCoord )*IN.vMultiTexBlend.z;
							
	float4 vAmbientColor = vDiffuceColor;
	
	vDiffuceColor *= dot(vNormalColor, IN.vLight);
	float3 vLightReflection = normalize( reflect(IN.vLight, vNormalColor) );	
	float4 vSpecularColor = float4(pow(max(0.0, dot(vLightReflection, IN.vCamera) ), 128.0f)) * IN.vMultiTexBlend.z;
	
	OUT.color = vDiffuceColor + vSpecularColor + vAmbientColor;
	
	OUT.color.a = 1.0f;
	if(IN.fClipValue.x < bReflectionPass)
		OUT.color.a = 0.0f;
	if(bReflectionPass < 0.0f)
		if(IN.fClipValue.x > bReflectionPass * ( -1.0f ))
			OUT.color.a = 0.0f;

	return OUT;
}
